# Summary of Project Requirements from "Opdracht Security.pdf"

This document outlines the requirements for adding security features to an existing Text Adventure game. The project consists of two main components: a client (the game) and a server (a minimal API).

## 1. Core Objective

The main goal is to "harden" the existing Text Adventure console game by integrating it with a secure API, implementing encryption for specific game areas, and adopting secure coding practices.

## 2. System Components

### 2.1. The API Server (Minimal API)

The API is responsible for all user and security management.

-   **User Management:**
    -   **Registration (`POST /api/auth/register`):** Creates new users, hashes their passwords using **SHA-256**, and assigns a role ('Player' or 'Admin'). Must handle cases where a username already exists.
    -   **Login (`POST /api/auth/login`):** Authenticates users by hashing the provided password and comparing it to the stored hash.
-   **Security Features:**
    -   **Lockout:** The API must lock out a user after 3 unsuccessful login attempts.
    -   **JWT Tokens:** Upon successful login, the API generates and returns a JWT to the client. It should also provide an endpoint (`GET /api/auth/me`) for clients to verify their identity and role using the JWT.
    -   **No Hardcoded Secrets:** The JWT signing key must not be hardcoded.
-   **Key Management:**
    -   **Keyshare Endpoint (`GET /api/keys/keyshare/{roomId}`):** The API provides "key shares" for encrypted rooms. Access to these key shares is role-based and requires a valid JWT.

### 2.2. The Text Adventure Client (Console App)

The client is the existing game, which needs to be extended to interact with the API.

-   **Authentication:**
    -   At startup, the game must prompt the user for a username and password.
    -   It sends these credentials to the API to log in.
    -   It must receive, store, and use the JWT for all subsequent authenticated API requests.
-   **Decryption:**
    -   The game must be able to open encrypted rooms (`.enc` files).
    -   To do this, it first requests a **key share** from the API for the specific room.
    -   It then prompts the user for a **passphrase**.
    -   A decryption key is generated by calculating: `SHA256(keyshare + ":" + passphrase)`.
    -   This key is used to decrypt the room file. The PDF specifies using **CMS (X.509)** encryption.
-   **Secure Coding:**
    -   **No Hardcoded Secrets:** The client code must not contain any hardcoded secrets (like passphrases or keys).
    -   **Input Validation:** All user input must be handled safely to prevent crashes or vulnerabilities.
    -   **Error Handling:** The game should display clear error messages and not crash on failures (e.g., failed decryption).

## 3. The Encryption Process

-   At least two rooms must be encrypted.
-   This encryption is performed by a separate tool or script, not within the game itself.
-   The process involves encrypting a plaintext file (e.g., `room_secret.txt`) into a ciphertext file (`room_secret.enc`) using **CMS / X.509**.
-   The decryption key is derived dynamically as described above.

## 4. Deliverables

The final submission must include:
-   The complete API project.
-   The complete Text Adventure client project.
-   At least two encrypted room files (`.enc`).
-   README files for the projects.

---

## 5. Note on Cryptographic Incompatibility (CMS/X.509 vs. SHA256 Key Derivation)

The original `Opdracht Security.pdf` presented a cryptographic conflict by requiring both:
1.  **X.509 / CMS encryption** (an asymmetric encryption scheme).
2.  A decryption key derived from **`SHA256(keyshare + ":" + passphrase)`** (which produces a symmetric key).

These two requirements are fundamentally incompatible:
*   **Asymmetric encryption (like CMS/X.509)** uses a public key for encryption and a distinct private key for decryption. The encryption key is typically not derived from a simple hash.
*   **Symmetric encryption (like AES-256)** uses the *same key* for both encryption and decryption. A key derived from `SHA256(keyshare + ":" + passphrase)` is perfectly suited for symmetric algorithms.

To resolve this contradiction, the implementation prioritized the key derivation method (`SHA256(keyshare + ":" + passphrase)`), as it represented a more nuanced security flow involving both the API and user input. Therefore, the project now uses **AES-256 symmetric encryption** for room content, as it is fully compatible with the specified key derivation. The explicit mention of "CMS (X.509)" in the PDF was thus superseded by the requirement for a hash-derived key.